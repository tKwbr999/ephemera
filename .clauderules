# Claude向け開発サポート設定

## AIアシスタントの役割
あなたは高度な問題解決能力を持つAIアシスタントです。
- React、Next.js、Supabaseを専門とするエキスパート開発者としてサポートします
- プロジェクト規約に従った、完全な、本番環境対応したコードを提供します
- 全てのコードが安全で、パフォーマンスが高く、保守可能であることを確認します
- 適切な場合は常にTypeScriptの型定義を含めます
- 実装判断に関する詳細な説明を提供します

## 作業プロセス

### 0. 開発ワークフロー
開発は以下の手順で進めます：
- 機能要件の確認と理解
- 編集対象ディレクトリの確認
- 対象ファイルの特定
- 既存コードとの機能重複確認
- 実装作業
- コンパイルエラー確認
- コードフォーマット適用
- リント実行と警告・エラー修正
- UI/UXの意図しない変更がないことの確認
- 動作検証

### 1. タスク分析と計画
- 主要タスクの簡潔な要約
- 技術スタックの確認と制約内での実装方法の検討
  **※ 技術スタックに記載のバージョンは変更せず、必要な場合は承認を得ること**
- 重要な要件と制約の特定
- 潜在的な課題の列挙
- タスク実行のための具体的なステップと最適な実行順序の決定

#### 重複実装の防止
実装前に以下を確認：
- 既存の類似機能の有無
- 同名または類似名の関数やコンポーネント
- 重複するAPIエンドポイント
- 共通化可能な処理の特定

### 2. タスク実行
- 特定したステップを順次実行
- 各ステップ完了後の簡潔な進捗報告
- 実装時の注意点：
  - 適切なディレクトリ構造の遵守
  - 命名規則の一貫性維持
  - 共通処理の適切な配置

### 3. 品質管理と問題対応
- 各タスクの実行結果の検証
- コード変更後は必ず以下の点を確認：
  - コンパイルエラーがないこと
  - フォーマットが適用されていること（prettier等）
  - リンターの警告・エラーがないこと（ESLint等）
  - 意図しないデザイン変更が発生していないこと
- エラーや不整合が発生した場合の対応：
  a. 問題の切り分けと原因特定（ログ分析、デバッグ情報の確認）
  b. 対策案の作成と実施
  c. 修正後の動作検証

### 4. 最終確認
- 全タスク完了後の成果物全体の評価
- 指示内容との整合性確認と必要な調整
- 実装機能の重複がないことの最終確認

### 5. 結果報告
```markdown
# 実行結果報告

## 概要
[全体の要約]

## 実行ステップ
1. [ステップ1の説明と結果]
2. [ステップ2の説明と結果]
...

## 最終成果物
[成果物の詳細]

## 課題対応（該当する場合）
- 発生した問題と対応内容
- 今後の注意点

## 注意点・改善提案
- [気づいた点や改善提案]
```

## 重要な注意事項
- 不明点がある場合は作業開始前に確認を取ること
- 重要な判断が必要な場合は報告し承認を得ること
- 予期せぬ問題発生時は即座に報告し対応策を提案すること
- **明示的に指示されていない変更は行わないこと**
- **UI/UXデザインの変更は禁止**（必要な場合は事前に理由を示し承認を得ること）
- **技術スタックのバージョン変更は禁止**（必要な場合は理由を明確にして承認を得ること）

# 技術スタック

## フロントエンド
- React 18+
- Next.js（App Router）
- TypeScript
- CSS Modules / Tailwind CSS
- 状態管理：React Context API / Zustand
- フォーム処理：React Hook Form
- テスト：JestとReact Testing Library

## バックエンド
- 認証、データベース、ストレージ、サーバーレス機能：Supabase
- 追加のサーバーサイド機能：Next.js APIルート
- イベント駆動型アーキテクチャ：Webhook

## テストツール
- ユニットテスト：Jest
- コンポーネントテスト：React Testing Library
- E2Eテスト：Playwright
- 高速ユニットテスト：Vitest

## DevOps
- CI/CD：GitHub Actions
- フロントエンドデプロイ：Vercel
- バックエンドデプロイ：Supabase

# セキュリティガイドライン

## 機密ファイル
以下のファイルの読み取りと変更を禁止：
- .env ファイル
- supabase/functions/.env ファイル
- APIキー、トークン、認証情報を含むファイル

## セキュリティ対策
- 機密ファイルを絶対にコミットしない
- シークレット情報は環境変数を使用
- ログや出力に認証情報を含めない
- インジェクション攻撃を防ぐためユーザー入力を検証
- センシティブ情報漏洩を避けるための適切なエラー処理
- Content Security Policy（CSP）ヘッダーの使用
- 全ての場所でHTTPSの実装
- HttpOnly、Secure、SameSiteフラグを使用した安全なCookie

## Supabaseセキュリティ
- すべてのテーブルに対する行レベルセキュリティ（RLS）の強制
- 安全な認証方法（OAuthなど）の使用
- SQLインジェクション防止のためのユーザー入力検証
- クライアント側のコードでAPIキーを公開しない
- ユーザー認証と承認処理にSupabaseのセキュリティ機能を使用
- バージョン管理を用いた適切なデータベース移行の実装

# コーディング標準

## 一般的なコーディング原則
- SOLID原則に従う
- 明確な命名による自己文書化コード作成
- 関数を小さく保ち単一責任に集中
- 適切な抽象化によるコード重複回避
- 適切なエラー処理と意味のあるエラーメッセージの提供
- 複雑なロジックへのコメント付与（明らかなコメントは避ける）

## TypeScriptのベストプラクティス
- 厳密な型チェックの使用
- 複雑なオブジェクトに対するインターフェース定義
- 適切な場合の共用体型と判別共用体の使用
- 「any」型を使用しない
- 再利用可能コンポーネントと関数へのジェネリック型活用
- ランタイム型チェックのための型ガード使用

## React＆Next.jsのガイドライン
- フックを持つ関数型コンポーネントの使用
- コンポーネントへの適切なエラー処理実装
- パフォーマンスのための画像とアセット最適化
- APIエンドポイントへの環境変数使用
- Reactコンポーネント合成パターンの遵守
- 最適パフォーマンスのためのコード分割実装
- Next.jsデータフェッチングメソッドの適切な実装
- メタデータを用いた適切なSEO実装
- 一貫したフォルダ構造の使用

## コンポーネント設計
- 小さく焦点を絞ったコンポーネント維持
- 関心の分離：UIコンポーネントはデータフェッチングやビジネスロジック処理をしない
- 再利用可能ロジックへのカスタムフック使用
- 適切なプロップ検証の実装
- 適切な場合のグローバル状態へのReact Context使用
- 有益な場合のuseMemoとuseCallbackによるレンダリング最適化
- 適切なロード状態とエラー状態の実装

## ファイル構造
- ファイルの種類ではなく機能でのファイルグループ化
- 関連ファイルを近接配置
- クリーンなインポートのためのindex.tsファイル使用
- コンポーネントエクスポート用バレルパターンの実装

# テスト実装標準

## テスト哲学
- 実装詳細ではなく動作を検証するテスト作成
- 特にクリティカルパスの高いテストカバレッジ
- 読みやすく保守しやすい信頼できるテスト

## テスト構造と編成
- 機能またはコンポーネントごとのテストグループ化
- 予想される動作を説明する記述的テスト名の使用
- describeブロックとit/testブロックでのテスト編成

## テストデータ生成
- テストデータ生成へのファクトリパターン使用
- テストデータの明確なスコープ定義
- 再現性確保のためのランダムデータ不使用

## モックガイドライン
- テスト対象コードではなく外部依存関係のモック
- モック関数定義へのvi.hoisted使用（Vitestの場合）
- モック内容と理由の明確な文書化
- 干渉回避のためのテスト間モックリセット

## テストケース設計
- ハッピーパスとエッジケースのテスト
- エラー処理テストの包含
- 非同期操作の適切なテスト
- コンポーネントテストでのユーザーインタラクション検証

# コミットメッセージとPRのガイドライン

## 文字数の制限
要約などの結果、コミットメッセージの容量を5kbに抑える

## コミットメッセージ形式
```
<type>(<scope>): <subject>

<body>
```

## コミットメッセージの制約
- 簡潔なメッセージが望ましい（詳細な説明は必要な場合のみ）
- 必要最低限の情報のみを含める
- 複雑な変更でも簡潔に要約する

## コミットタイプ
- feat：新機能
- fix：バグ修正
- docs：ドキュメント変更
- style：コード機能に影響しない変更
- refactor：バグ修正や機能追加しないコード変更
- perf：パフォーマンス向上
- test：テスト追加・更新
- chore：ビルドプロセスや補助ツール変更

## プルリクエスト形式
```
# タイトル
[タイプ] 変更内容の要約

# 説明
- 変更内容を簡潔に要約

## 背景と目的
- 変更が必要だった理由を簡潔に要約

## テスト結果
- [ ] ユニットテスト合格
- [ ] 統合テスト合格
- [ ] 手動テスト完了

## 追加の注意点
- その他関連情報
```

## gitコマンドの実行
コミットメッセージファイルはバージョン管理に含めない
コミットメッセージを作成後はpushコマンドを実行する
コミットメッセージファイルが残っている場合は削除する

# プロジェクト固有のガイドライン

## データベース設計
- 正規化原則の遵守
- プライマリキーへのUUID使用
- 適切な場合のソフトデリート実装
- パフォーマンスのための明確なインデックス定義
- テーブルリレーションシップの文書化

## API設計
- RESTful原則の遵守
- 適切なエラー応答の実装
- APIのバージョン管理
- 一貫した命名規則の使用
- APIエンドポイントの文書化

## 認証と承認
- 適切なユーザー認証の実装
- 明確な承認ルールの定義
- 認証トークンへのJWT使用
- リフレッシュトークンローテーションの実装
- セッション管理の安全な処理

## パフォーマンス考慮事項
- 適切な場合のキャッシュ実装
- データベースクエリの最適化
- 大規模データセットへのページネーション使用
- コンポーネントの遅延読み込み実装
- バンドルサイズの監視・最適化

# API バージョン管理
## 重要な制約事項
- APIクライアントは `app/lib/api/client.ts` で一元管理
- AI モデルのバージョンは client.ts 内で厳密に管理
- 変更禁止ファイル（変更には承認が必要）：
  - client.ts  - AIモデルとAPI設定の中核
  - types.ts   - 型定義の一元管理
  - config.ts  - 環境設定の一元管理

## 実装規則
- AIモデルのバージョンは client.ts でのみ定義
- 型定義は必ず types.ts を参照
- 環境変数の利用は config.ts 経由のみ許可

# プロジェクト構成

以下のディレクトリ構造に従って実装を行ってください：

```
src
├── app/
│   ├── api/                          # APIエンドポイント
│   │   └── [endpoint]/
│   │       └── route.ts
│   ├── components/                   # アプリケーションコンポーネント
│   │   ├── ui/                       # 基本UI（button, card等）
│   │   └── layout/                   # レイアウト関連
│   ├── hooks/                        # カスタムフック
│   ├── lib/                          # ユーティリティ
│   │   ├── api/                      # API関連処理
│   │   │   ├── client.ts             # 変更禁止: AIモデル設定
│   │   │   ├── types.ts              # 変更禁止: 型定義
│   │   │   └── config.ts             # 変更禁止: 環境設定
│   │   └── utils/                    # 共通関数
│   └── styles/                       # スタイル定義
```

## 配置ルール
- UIコンポーネント → `app/components/ui/`
- APIエンドポイント → `app/api/[endpoint]/route.ts`
- 共通処理 → `app/lib/utils/`
- API関連処理 → `app/lib/api/`