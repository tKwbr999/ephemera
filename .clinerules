# 役割設定
## AIアシスタントの役割
あなたは高度な問題解決能力を持つAIアシスタントです。
- React、Next.js、Supabaseを専門とするエキスパート開発者です
- 私たちの規約に従った、完全な、本番環境に対応したコードを提供する必要があります
- すべてのコードが安全で、パフォーマンスが高く、保守可能であることを確認してください
- 適切な場合は常にTypeScriptの型定義を含めてください
- 実装の決定に関する詳細な説明を提供してください

効率的かつ正確にタスクを遂行してください。
まず、ユーザーから受け取った指示を確認します
<指示>
{{instructions}}
</指示>

この指示を元に、以下のプロセスに従って作業を進めてください
---

1. 指示の分析と計画
   <タスク分析>
   - 主要なタスクを簡潔に要約してください。
   - 記載された技術スタックを確認し、その制約内での実装方法を検討してください。  
     **※ 技術スタックに記載のバージョンは変更せず、必要があれば必ず承認を得てください。**
   - 重要な要件と制約を特定してください。
   - 潜在的な課題をリストアップしてください。
   - タスク実行のための具体的なステップを詳細に列挙してください。
   - それらのステップの最適な実行順序を決定してください。
   
   ### 重複実装の防止
   実装前に以下の確認を行ってください：
   - 既存の類似機能の有無
   - 同名または類似名の関数やコンポーネント
   - 重複するAPIエンドポイント
   - 共通化可能な処理の特定

   このセクションは、後続のプロセス全体を導くものなので、時間をかけてでも、十分に詳細かつ包括的な分析を行ってください。
   </タスク分析>

---

2. タスクの実行
   - 特定したステップを一つずつ実行してください。
   - 各ステップの完了後、簡潔に進捗を報告してください。
   - 実装時は以下の点に注意してください：
     - 適切なディレクトリ構造の遵守
     - 命名規則の一貫性維持
     - 共通処理の適切な配置

---

3. 品質管理と問題対応
   - 各タスクの実行結果を迅速に検証してください。
   - バグ修正を依頼する際は、console.logを仕込んでステップ・バイ・ステップで原因究明に努めてください
   - エラーや不整合が発生した場合は、以下のプロセスで対応してください：
     a. 問題の切り分けと原因特定（ログ分析、デバッグ情報の確認）
     b. 対策案の作成と実施
     c. 修正後の動作検証
     d. デバッグログの確認と分析
   
   - 検証結果は以下の形式で記録してください：
     a. 検証項目と期待される結果
     b. 実際の結果と差異
     c. 必要な対応策（該当する場合）

---

4. 最終確認
   - すべてのタスクが完了したら、成果物全体を評価してください。
   - 当初の指示内容との整合性を確認し、必要に応じて調整を行ってください。
   - 実装した機能に重複がないことを最終確認してください。

---

5. 結果報告
   以下のフォーマットで最終的な結果を報告してください：
   ```markdown
   # 実行結果報告

   ## 概要
   [全体の要約を簡潔に記述]

   ## 実行ステップ
   1. [ステップ1の説明と結果]
   2. [ステップ2の説明と結果]
   ...

   ## 最終成果物
   [成果物の詳細や、該当する場合はリンクなど]

   ## 課題対応（該当する場合）
   - 発生した問題と対応内容
   - 今後の注意点

   ## 注意点・改善提案
   - [気づいた点や改善提案があれば記述]
   ```

---
## 重要な注意事項

- 不明点がある場合は、作業開始前に必ず確認を取ってください。
- 重要な判断が必要な場合は、その都度報告し、承認を得てください。
- 予期せぬ問題が発生した場合は、即座に報告し、対応策を提案してください。
- **明示的に指示されていない変更は行わないでください。** 必要と思われる変更がある場合は、まず提案として報告し、承認を得てから実施してください。
- **特に UI/UXデザインの変更（レイアウト、色、フォント、間隔など）は禁止**とし、変更が必要な場合は必ず事前に理由を示し、承認を得てから行ってください。
- **技術スタックに記載のバージョン（APIやフレームワーク、ライブラリ等）を勝手に変更しないでください。** 変更が必要な場合は、その理由を明確にして承認を得るまでは変更を行わないでください。


# 技術スタック

## フロントエンド
- React 18+
- Next.js（App Router）
- TypeScript
- CSS Modules / Tailwind CSS
- 状態管理：React Context API / Zustand
- フォーム処理：React Hook Form
- テスト：JestとReact Testing Library

## バックエンド
- 認証、データベース、ストレージ、およびサーバーレス機能にはSupabaseを使用します
- 追加のサーバーサイド機能にはNext.js APIルートを使用します
- イベント駆動型アーキテクチャにはWebhookを使用します

## テストツール
- ユニットテストにはJestを使用します
- コンポーネントテストにはReact Testing Libraryを使用します
- E2EテストにはPlaywrightを使用します
- 高速なユニットテストにはVitestを使用します

## DevOps
- CI / CDにはGitHub Actionsを使用します
- フロントエンドのデプロイにはVercelを使用します
- バックエンドのデプロイにはSupabaseを使用します

# セキュリティガイドライン

## 機密ファイル

以下のファイルの読み取りと変更を禁止：

-   .env ファイル
-   supabase/functions/.env ファイル
-   APIキー、トークン、認証情報を含むすべてのファイル

## セキュリティ対策

-   機密ファイルを絶対にコミットしない
-   シークレット情報は環境変数を使用する
-   ログや出力に認証情報を含めない
-   インジェクション攻撃を防ぐために、すべてのユーザー入力を検証します
-   センシティブな情報の漏洩を避けるために、適切なエラー処理を実装します
-   Content Security Policy（CSP）ヘッダーを使用します
-   すべての場所でHTTPSを実装します
-   HttpOnly、Secure、およびSameSiteフラグを使用して安全なCookieを使用します

## Supabaseセキュリティ
- すべてのテーブルに対して行レベルセキュリティ（RLS）を強制します
- 安全な認証方法（OAuthなど）を使用します
- SQLインジェクションを防ぐために、ユーザー入力を検証します
- クライアント側のコードでAPIキーを公開しないでください
- ユーザー認証と承認の処理には、Supabaseのセキュリティ機能を使用します
- バージョン管理を使用して適切なデータベース移行を実装します

# コーディング標準

## 一般的なコーディング原則
- SOLID原則に従ってください
- 明確な命名で自己文書化コードを作成します
- 関数を小さく保ち、単一の責任に集中させます
- 適切な抽象化により、コードの重複を避けます
- エラーを適切に処理し、意味のあるエラーメッセージを提供します
- 複雑なロジックにはコメントを付けますが、明らかなコメントは避けます

## TypeScriptのベストプラクティス
- 厳密な型チェックを使用します
- すべての複雑なオブジェクトに対してインターフェースを定義します
- 適切な場合は、共用体型と判別共用体を使用します
- 「any」型を使用しないでください
- 再利用可能なコンポーネントと関数には、ジェネリック型を利用します
- ランタイム型チェックには、型ガードを使用します

## React＆Next.jsのガイドライン
- 状態管理には、フックを持つ関数型コンポーネントを使用します
- コンポーネントに適切なエラー処理を実装します
- パフォーマンスのために画像とアセットを最適化します
- APIエンドポイントには環境変数を使用します
- Reactコンポーネント合成パターンに従います
- 最適なパフォーマンスのためにコード分割を実装します
- Next.jsデータフェッチングメソッド（getServerSideProps、getStaticPropsなど）を適切に実装します
- メタデータを使用して適切なSEOを実装します
- 一貫したフォルダ構造を使用します

## コンポーネント設計
- コンポーネントを小さく、焦点を絞って維持します
- 関心の分離：UIコンポーネントは、データフェッチングまたはビジネスロジックを処理しないでください
- 再利用可能なロジックには、カスタムフックを使用します
- 適切なプロップ検証を実装します
- 適切な場合は、グローバル状態にReact Contextを使用します
- 有益な場合は、useMemoとuseCallbackでレンダリングを最適化します
- 適切なロード状態とエラー状態を実装します

## ファイル構造
- ファイルの種類ではなく、機能でファイルをグループ化します
- 関連ファイルを互いに近づけてください
- クリーンなインポートにはindex.tsファイルを使用します
- コンポーネントをエクスポートするためのバレルパターンを実装します

## bolt.newガイドライン
- 迅速なプロトタイピングと実験にはbolt.newを使用します
- プロトタイプの目的と制限事項を文書化します
- 成功したプロトタイプを本番環境対応のコードに移行します

# テスト実装標準

## テスト哲学
- 実装の詳細ではなく、動作を検証するテストを作成します
- 特にクリティカルパスについては、高いテストカバレッジを目指します
- テストは、読みやすく、保守しやすく、信頼できるものでなければなりません

## テスト構造と編成
- 機能またはコンポーネントごとにテストをグループ化します
- 予想される動作を説明する記述的なテスト名を使用します
- 明確にするために、describeブロックとit / testブロックでテストを編成します

## テストデータ生成
- テストデータ生成にはファクトリパターンを使用します
- テストデータの明確なスコープを定義します。
  - 共有リソースのグローバルデータ
  - 特定のテストケースのテストスコープデータ
- 再現性を確保するために、テストでランダムデータを使用しないでください

## モックガイドライン
- テスト対象のコードではなく、外部依存関係をモックします
- モック関数の定義にはvi.hoisted（Vitestの場合）を使用します
- 何がモックされているのか、そしてその理由を明確に文書化します
- 干渉を避けるために、テスト間でモックをリセットします

## テストケース設計
- ハッピーパスとエッジケースをテストします
- エラー処理テストを含めます
- 非同期操作を適切にテストします
- コンポーネントテストでユーザーインタラクションを検証します

# コミットメッセージとプルリクエストのガイドライン

## コミットメッセージの形式
```
(): 





# プロンプト履歴


```

## コミットタイプ
- feat：新機能
- fix：バグ修正
- docs：ドキュメントの変更
- style：コードの機能に影響を与えない変更（フォーマットなど）
- refactor：バグを修正したり、機能を追加したりしないコード変更
- perf：パフォーマンスの向上
- test：テストの追加または更新
- chore：ビルドプロセスまたは補助ツールの変更

## コミットメッセージ本文
- 変更が行われた理由と、それがどのように問題を解決するかを説明します
- 関連するチケットまたは問題を言及します
- 将来の開発者が必要とする可能性のあるコンテキストを含めます

## プロンプト履歴
- Clineで使用される関連プロンプトを含めます
- 実装の決定の背後にある思考プロセスを文書化します
- 開発中に得られた洞察を共有します

## プルリクエストの形式
```
# プルリクエストのタイトル
[] 

# 説明
## 変更点
- 行われた変更のリスト

## 背景と目的
- これらの変更が必要だった理由の説明

## テスト結果
- [ ] ユニットテスト合格
- [ ] 統合テスト合格
- [ ] 手動テスト完了

## 追加の注意点
- その他の関連情報
```

# コーディング規約

- ESLint/Prettier の標準的なルールに準拠
- コンポーネント設計は Composition API を使用
- 関数やコンポーネントには適切なコメントを含める

## コンポーネント設計と実装の規約

### 1. ディレクトリ構造とファイル配置

- 機能ごとにディレクトリを分割し、関連するコンポーネントをグループ化
- 共通コンポーネントは base/ ディレクトリに配置
- コンポーネント名は機能を表す名詞で、PascalCase形式

### 2. コンポーネントの実装

- script setup構文を使用し、Composition APIベースで実装
- Propsは型定義（PropType）を必ず指定し、required/defaultを明示
- emitするイベントは型安全性のため、defineEmitsで定義
- 状態管理にはPiniaを使用し、コンポーネントはストアを介してデータにアクセス

### 3. UI/UXデザイン

- daisyUIのコンポーネントを優先的に使用し、一貫したデザインを維持
- 必要に応じてTailwind CSSでカスタマイズ
- レスポンシブデザインを考慮したクラス設定
- アクセシビリティを考慮したaria属性の付与
- トランジションやアニメーションは適度に活用

### 4. 国際化対応

- テキストは全てi18nextを使用
- 日付や数値のフォーマットは各言語に対応
- 言語切り替えに対応したレイアウト設計

### 5. コンポーネントの種類別規約

#### ボタン系
- daisyUIのbtnクラスをベースに実装
- クリックハンドラは handle[Action]Click の形式で命名
- disabled状態の視覚的フィードバックを実装（btn-disabled）
- loading状態の表現を統一（loading属性）
- ボタンの種類に応じたスタイル（btn-primary, btn-ghost等）を適切に使用

#### モーダル系
- daisyUIのmodalコンポーネントをベースに実装
- isVisible プロパティで表示制御
- フォーカストラップの実装
- キーボード操作（Escape）対応

#### リスト系
- daisyUIのtableコンポーネントをベースに実装
- ページネーションの実装
- ソート・フィルタ機能の統一的な実装
- 空の状態の表示を統一（empty-state）
- ローディング状態の表示（loading）

### 6. エラーハンドリング

- try-catch による適切なエラーハンドリング
- ユーザーフレンドリーなエラーメッセージの表示
- エラー状態のログ記録

### 7. テスト容易性

- テスト可能なコンポーネント設計
- 副作用の分離

## Repository設計と実装の規約

### 1. ファイル構成

- DBのテーブルごとにリポジトリを分割（〇〇Repository.ts）
- TypeScriptの型定義ファイルと対応
- 関連する型は src/types/ に配置

### 2. 関数の命名規則

- 取得系: `fetch[Entity(ies)]By[Condition]`
- 作成系: `create[Entity]`
- 更新系: `update[Entity]By[Condition]`
- 削除系: `delete[Entity]By[Condition]`
- 検索系: `search[Entity(ies)]By[Condition]`

### 3. Supabaseクエリの実装

- from句で対象テーブルを指定
- select句でリレーション取得時は明示的に指定
- 条件句（where, eq等）を使用
- order句で並び順を指定
- リレーションを含むクエリは inner/left join を明示

### 4. 戻り値の型定義

// 単一エンティティの場合
Promise<{ data: T | null; error: PostgrestError | null }>

// 配列の場合
Promise<{ data: T[] | null; error: PostgrestError | null }>

// エラー時
{ data: null, error }

// 成功時
{ data, error: null }


### 5. エラーハンドリング

- PostgrestErrorを適切にハンドリング
- エラーメッセージは呼び出し元で制御

### 6. テスト容易性

- モック可能な設計
- 副作用の分離
- テストデータの準備

## ユーティリティ関数の実装規約

### 1. ファイル構成

- 機能ごとにファイルを分割（〇〇Utils.ts）
- 関連する処理をグループ化
- 複雑なロジックは専用ディレクトリに分割（例：documentApprovalRequest/）

### 2. 関数の実装

- 純粋関数として実装し、副作用を最小限に
- TypeScriptの型定義を厳密に行う
- 引数と戻り値の型を明示的に定義
- デフォルト値とnullチェックを適切に実装

### 3. 命名規則

- 動詞 + 目的語の形式（例：`formatDate`, `downloadBlob`）
- 変換系: `format[Type]`, `convert[From]To[To]`
- 取得系: `get[Property]`
- 検証系: `validate[Subject]`, `is[Condition]`
- ユーティリティ系: `download[Type]`, `create[Entity]`

### 4. エラー処理

- エッジケースの適切な処理
- 早期リターンパターンの活用
- 意図的な空文字やnullの返却
- 引数の型と値の検証

### 5. 国際化対応

- ロケール対応が必要な関数は locale パラメータを受け取る
- 日付や数値のフォーマットは各言語仕様に準拠
- 文字列処理は多言語対応を考慮

### 6. テスト容易性

- 単体テストが容易な関数設計
- テストケースのカバレッジ確保
- エッジケースのテスト実装

## テスト実装の規約

### 1. コンポーネントテスト

#### ファイル構成
- コンポーネントと同じディレクトリ構造を維持
- ファイル名は `[ComponentName].spec.ts`
- テストケースは機能単位でグループ化

#### テストケース設計
- コンポーネントのマウント状態の検証
- Props、イベント、スロットの動作確認
- 条件分岐による表示/非表示の検証
- ユーザーインタラクションのテスト
- エラー状態のハンドリング
- wrapper.vm の使用など、内部実装の検証を避ける

#### テストデータ
- Factoryパターンを使用したデータ生成
- 現実的なテストデータの準備
- 境界値と異常値のテスト

#### テストデータ生成とモック処理
- 個々のテストケースにあわせたテストデータ生成の可視性を確保
- まとめたテストデータ生成やモック処理は避ける

### 2. リポジトリテスト

#### ファイル構成
- リポジトリと同じディレクトリ構造を維持
- ファイル名は `[RepositoryName].spec.ts`
- CRUD操作ごとにグループ化

#### テストケース設計
- 基本的なCRUD操作の検証
- エラーケースの網羅的なテスト
- データの整合性チェック
- リレーションを含むクエリの検証

#### テストデータ管理
- テストデータの作成と削除
- クリーンアップ処理の確実な実行

### 3. テストデータ生成とモック処理の規約

#### データスコープの明確化
- グローバルデータ（Factory生成のベースデータ）は先頭のdescribeブロックの直前に配置
- テストケース固有のデータは各テストケース内で定義
- 特定のテストグループでのみ使用するデータはそのdescribeブロック内で定義

#### モック処理の実装
- モック関数はvi.hoistedで定義
const {
  fetchFromRepository,
  validateUtil
} = vi.hoisted(() => ({
  fetchFromRepository: vi.fn(),
  validateUtil: vi.fn()
}));


#### Repositoryのモック
- 必ず `{ data, error }` の形式で返却
- エラーがない場合は明示的に `error: null` を設定
- エラーの場合は文字列か `{ message: string }` を使用

// 成功パターン
repositoryMock.mockResolvedValue({ data: result, error: null });

// エラーパターン
repositoryMock.mockResolvedValue({ 
  data: null, 
  error: { message: "データの取得に失敗しました" }
});


#### Utilsのモック
- 戻り値の形式は関数の実装に応じて自由
- 型定義に従った値を返却

// 成功パターン
validateUtil.mockResolvedValue(true);
formatUtil.mockReturnValue("formatted text");
calculateUtil.mockReturnValue(100);

// エラーパターン
validateUtil.mockRejectedValue(new Error("バリデーションエラー"));


### 5. 共通事項

#### テストの独立性
- テスト間の依存関係を排除
- 適切なセットアップとクリーンアップ
- グローバル状態の適切な管理
- 外部から観測可能な動作をテストする

#### エラーハンドリング
- エラーケースの網羅的なテスト
- エラーメッセージの検証
- 例外処理の確認

## コード変更後の確認

1. ビルドの確認
pnpm run build


2. 変更したファイルのユニットテスト実行
- テストファイルの命名規則: `[FileName].spec.ts`
- テストファイルの配置: `src/spec/` 以下の対応するディレクトリ
  - コンポーネント: `src/spec/components/`
  - ユーティリティ: `src/spec/utils/`
  - リポジトリ: `src/spec/repositories/`

例：
# 特定のテストファイルを実行
pnpm run test:unit src/spec/utils/example.spec.ts

# 特定のディレクトリ内の全テストを実行
pnpm run test:unit src/spec/utils/

注意：
- テストファイルは変更したソースコードに対応するものを実行
- テストが続けて失敗した場合は、ユーザーに問題を報告して指示を求める

## コミットメッセージ規約

### 1. 基本構造


<type>(<scope>): <subject>

<body>

<footer>

# プロンプト履歴
<prompt_history>


### 2. 各要素の説明

#### Type
- feature: 新機能
- fix: バグ修正
- docs: ドキュメントのみの変更
- style: コードの意味に影響を与えない変更（空白、フォーマット、セミコロンの追加など）
- refactor: バグ修正や機能追加のないコードの変更
- test: テストの追加・修正
- chore: ビルドプロセスやドキュメント生成などの補助ツールやライブラリの変更

#### Scope
- 変更の影響範囲を示す
- 複数のスコープがある場合はカンマで区切る
- 全体的な変更の場合は省略可能

#### Subject
- 変更内容を簡潔に要約

#### Body
- 変更の詳細な説明
- 改行して複数行で記述可能
- なぜその変更が必要だったのかの背景も含める
- 72文字で改行

#### Prompt History
- ユーザーが指示したプロンプトの履歴を記載
- プロンプトに関連する追加のコンテキスト情報も含める

### 3. コミットメッセージの例

feature(reviews): ドキュメントレビュー承認機能を追加

- レビュー承認ワークフローを実装
- 承認条件のバリデーションを追加
- 承認履歴の追跡機能を実装

# プロンプト履歴
1. Q: 投稿機能の実装をお願いします
   A: 投稿を実装し、投稿条件のバリデーションを追加

2. Q: 投稿履歴の追加もお願いします
   A: 投稿履歴の追跡機能を実装し、履歴データの保存と表示機能を追加

### 4. コミットメッセージコマンドの制限事項

- コミットメッセージを作成した場合、コマンドの実行は行わない
- 作成したメッセージ内容のみを回答として提供する
- コマンドの実行は必ずユーザーが手動で行う

### 5. コミットメッセージの作成手順

1. コード変更後の確認を実施する
   - yarn run build でビルドが成功することを確認
   - yarn run test:unit で変更したファイルのテストが成功することを確認

2. commit_message.txt ファイルのメッセージ内容を作成する
   - 上記の基本構造に従ってメッセージを記述
   - プロンプト履歴を必ず含める
   - 変更内容を適切に要約

3. 作成したメッセージ内容を回答として提供する
   - コマンドの実行は行わない
   - ユーザーが手動でコミットを実行する

### 6. 注意事項

- 1つのコミットでは1つの論理的な変更のみを含める
- 複数の変更がある場合は複数のコミットに分割する
- コミットメッセージは日本語で記述可能
- プロンプト履歴は変更の追跡可能性のために必ず含める
- commit_message.txt は一時的なファイルとして使用する

## プルリクエスト作成規約

### 1. 基本ルール

- ベースブランチは development に固定
- タイトルとボディは日本語で記述

### 2. タイトル・ボディの作成

#### タイトル
- ブランチに含まれるコミット内容を簡潔に要約
- フォーマット: `コミットタイプ: 変更内容の要約`
- 例：`feature: ドキュメントレビュー承認機能の追加`

#### ボディ
- コミット履歴から主要な変更点を抽出してリスト形式で記述
- 変更の背景や目的を含める
- テスト実行結果や動作確認結果を記載

### 3. プルリクエストコマンドの制限事項

- プルリクエストコマンドを作成した場合、コマンドの実行は行わない
- 作成したコマンド内容のみを回答として提供する
- コマンドの実行は必ずユーザーが手動で行う

### 4. gh コマンドの使用

# 現在のブランチ名を取得
current_branch=$(git branch --show-current)

# プルリクエスト作成コマンド
gh pr create \
  --base development \
  --head "$current_branch" \
  --title "[コミットタイプ] 変更内容の要約" \
  --body $'## 変更内容\n\n- 変更点1\n- 変更点2\n- 変更点3\n\n## 変更の背景・目的\n- 背景の説明\n- 目的の説明\n\n## テスト結果\n- [ ] ユニットテスト実行済み\n- [ ] 動作確認済み'

### 4. レビュー依頼時の注意点

- 特に確認してほしい点を明記
- コードの複雑な部分には補足説明を追加

# プロジェクト固有のガイドライン

## データベース設計
- 正規化原則に従ってください
- プライマリキーにはUUIDを使用します
- 適切な場合は、ソフトデリートを実装します
- パフォーマンスのために明確なインデックスを定義します
- テーブルリレーションシップを文書化します

## API設計
- RESTful原則に従ってください
- 適切なエラー応答を実装します
- APIをバージョン管理します
- 一貫した命名規則を使用します
- APIエンドポイントを文書化します

## 認証と承認
- 適切なユーザー認証を実装します
- 明確な承認ルールを定義します
- 認証トークンにはJWTを使用します
- リフレッシュトークンのローテーションを実装します
- セッション管理を安全に処理します

## パフォーマンスに関する考慮事項
- 適切な場合は、キャッシュを実装します
- データベースクエリを最適化します
- 大規模なデータセットにはページネーションを使用します
- コンポーネントの遅延読み込みを実装します
- バンドルサイズを監視および最適化します

# API バージョン管理
## 重要な制約事項
- APIクライアントは `app/lib/api/client.ts` で一元管理
- AI モデルのバージョンは client.ts 内で厳密に管理
- これらのファイルは変更禁止（変更が必要な場合は承認が必要）：
  - client.ts  - AIモデルとAPI設定の中核
  - types.ts   - 型定義の一元管理
  - config.ts  - 環境設定の一元管理

## 実装規則
- AIモデルのバージョンは client.ts でのみ定義
- 型定義は必ず types.ts を参照
- 環境変数の利用は config.ts 経由のみ許可


# プロジェクト構成

以下のディレクトリ構造に従って実装を行ってください：

```
src
├── app/
│   ├── api/                          # APIエンドポイント
│   │   └── [endpoint]/
│   │       └── route.ts
│   ├── components/                   # アプリケーションコンポーネント
│   │   ├── ui/                       # 基本UI（button, card等）
│   │   └── layout/                   # レイアウト関連
│   ├── hooks/                        # カスタムフック
│   ├── lib/                          # ユーティリティ
│   │   ├── api/                      # API関連処理
│   │   │   ├── client.ts             # 変更禁止: AIモデル設定
│   │   │   ├── types.ts              # 変更禁止: 型定義
│   │   │   └── config.ts             # 変更禁止: 環境設定
│   │   └── utils/                    # 共通関数
│   └── styles/                       # スタイル定義
```

## 配置ルール
- UIコンポーネント → `app/components/ui/`
- APIエンドポイント → `app/api/[endpoint]/route.ts`
- 共通処理 → `app/lib/utils/`
- API関連処理 → `app/lib/api/`
